Simulation engine simcity like

Road 1x1, serves also electricity and water
Road coverage 3x3
Building 1x1 for now, needs to be under road coverage
Road as connected component, each road a list of 1 tile building linked to it
Multiple tile building are cumulating their cost to a master tile, which will be the road connection


Demand RCI
Should be a local demand

Lot
* Level 
Indicates potency to meed demand
Capped by density
Increase if conditions met

Residential lot
*** Level 0
* Provides
Nothing
* Requires
1 Water
1 Electricity
Road
4 r demand

*** Level 1
* Provides
4 r unit
2 c demand
2 i demand
* Requires
1 Water
1 Electricity
Road
6r demand

*** Level 2
* Provides
10 r units
6 c demand
4 i demand
* Requires
2 water
2 electricity
8 demand met


* Commercial Lot
*** Level 0
* Provides
Nothing
* Requires
1 Water
1 Electricity
Road
4 c demand
*** Level 1
* Provides
4 c unit
4 r demand
2 i demand
* Requires
1 Water
1 Electricity
Road
2 demand met


Demand RCIO
Demand defined as the difference between actual unit and target unit.
time taken to raise level if requirement reached, then a new lot if none in waiting


asks 8r
Plop 2 residentials
electricity water road met
8 r, asks 4c 4i
Plop 1 commercial
8r 4c, asks 4r 6i
Plop 1 industrial
8r 4c 4i, asks 8r 2c 2i
Plop 1 residential
12r 4c 4i, asks 4r 4c 4i
Plop 1 commercial 1 industrial
12r 8c 8i, asks 12r 2c 2i
Plop 1 residential
16r 8c 8i, asks 8r 4c 4i
Plop 1 commercial 1 industrial
16r 12c 12i, asks 16r 2c 2i
Plop 1 residential
20r 12c 12i, asks 12r 4c 4i
Plop 1 commercial 1 industrial
20r 16c 16i, asks 20r 2c 2i
Plop 5 residential
40r 16c 16i, asks 0r 12c 12i
Plop 1 commercial 1 industrial
40r 20c 20i, asks 8r 10c 10i




4 res = 16r asks 8c 8i
2 com = 8c asks 4r 4i
2 ind = 8i asks 4r 4c

10 res = 40r asks 20c 20i
5 com = 20c asks 20r 10i
5 ind = 20i asks 20r 10c



Algorithm for RCIO resolution

Road network
Electricity/water
Each road can ask used and total capacity
Disconnected roads have different capacity

Function master check
Get next candidate for resolution
Check maintenance requirements
If maintenance requirements not met
  Downgrade? Disable? Provide no income? Upkeep cost? finish
Check level up requirements
If level up requirements met
  Upgrade, finish


Function check maintenance requirements
If none
  Finish ok
if need electricity
  If used > total capacity
    Finish no
If need water
  If used > total capacity
    Finish no

Function check level up requirements
if need road
  if no road, Finish no
If need electricity
  If not enough free capacity
    Finish no
  Add usage
if need water
  If not enough free capacity
    Finish no
  Add usage

A building provides units to a road.
A building has demand, starts from the nearest
road, and explore until it finds a free road
with free units.
If a building is removed, its units are removed
from its road and during the next cycle, a
building that used the road will remove
the full amount of the demand from it.
Number will go below capacity.

The rico statistics are hold in road.


Alternative
Process the simulation by type

Ratio of power/water grid determines income percentage.

Building residential has a requirement to have 
access to x commercial, x industrial. 
Remove all previous traffic. 
One traffic itinerary is set as a list of 
waypoints. 
Remove all traffic itinerary. 
Note that removing a road will not remove the 
traffic itineraries that go through this 
deleted road. 
They will naturally be deleted the next time 
the building is resolved. 
Starting from building location, 
explore the grid to find free commercial 
capacity, free industrial capacity, 
taking into account the existing traffic. 
Once a building is found, add an itinerary. 
Add back congestion level.

For converging to an optimal solution and 
reduce traffic,  two buildings with overlapping 
traffic could exchange itineraries that cross 
each other. 

Building resolution happens in cycle.
The scanning is arbitrary and starts at the
beginning of the map.
It iterates over the map index by index.
Alternatively, it can also moves in a building
queue, but the logic of adding and removing
from the queue must be solid. An example can
be a queue that grows as building are added
in fifo way. As a building is destroyed,
the tile is added to the queue, and scanning
an empty tile will just make it not queued the
next time. This way, scanning is performed
in a more economical method. In any case,
best is just a function that returns the next
tile to resolve (there may be no buildings).
Placing a building or replacing it will
update its sprite, but not its simulation data.
The simulation data is updated only upon
resolution.
The simulation data will hold a different state
than what is shown upon a change but it is fine.

A building has an object that holds all the data
it needs for its resolution? or is it through
data tables? If it is table then
Zone id table, 8 bit or 16 bit
Density table, 8 bit
Pollution table, 8 bit
Congestion table (road), 8 bit
Speed table (road), 8 bit
Debug table (road), 8 bit
RICO offer * 4 (road), 8 or 16 bit
Connect tables * 4 (road), 8 bit ot bitmask

Using everything as table may be worthwhile,
but memory consuming?
Road admittedly only consumes, conservatively
a third of the map.
May be interesting to use unsigned int array
tables if they are faster, even limited
to 255 with 8 bit values for memory constraint.

Connect to is 4 direction, which requires only
4 bits, so a number from 0 to 15 is enough.
However, current implementation is holding the
index of the connected route, not just a flag.



Road network is an example of not array table
based, but hash table based. Array table may
be fine for data that is one value per index.
Hash table will be
necessary for more complex data. A consideration
is the size required for holding a table with
mostly empty data. Todo search hash vs array
memory consumption.
In term of performance, holey array have 10%
the efficiency of a packed array. A holey
array is one where there is an undefined
object in the mix.

Note that the scheme of using cantor indexing
has a big overhead (twice memory reserved vs
compact indexing while only half of it is used)
but it allows extending.
If extending is a goal, then it may be better
to segment the grid into sub units, sub units
have compact indexing while unit grid is hash
based? Display would be limited to
a sub unit.
Sim city 4 small city is 64x64, large city 
is 256x256. It allows region play so there
is that too. But for starters, it is fine,
hence there would be no need to support
extending dynamically, and so a static
indexing would work. However, extending
will be based on region play, So there is
the connection between regions to take into
account. One could say, if a region is a
similation state, then it could be loaded,
churned into the engine, and updated without
having to display anything.
And so, keeping a sub unit to be 256*256 would
be memory efficient for data tables.
Junction roads between sub units however
need to be smart. For now, a road holds the unit
capacity provided by direct adjacents buildings.
A building having demands will explore the
network to feed on road capacity.
For subunits junctions, it can be thought as
checkpoints. Once all buildings have been served,
roads with remaining capacity can route to
these junctions and add up the free capacity
of that node + actual cost to fill that capacity
(on the sub unit provider).
Then on resolution of the neighbour subunit
(consumer), a traversal that explore the
junction will interpret it as a road with
free capacity (associated with a cost).
A difficulty resides in knowing whether to
settle with the junction, or to keep going.
As you see, a junction has many costs possible
so it does not fare well with bfs exploration.
Indeed in bfs it is supposed to resolve the
demand on a tile that is next candidate for
lowest cost. A solution would be to populate
the junction with many connections, not only
one road.
Once the consumer side has finished, the
provider side needs to update its congestion.
The junction becomes a consumer that has demand,
and must be processed as such by exploring the
network and add back congestion to the roads.

How to describe demand/capacity on a junction?
A road is ultimately a provider first:
The provision unit is as such:
- type: rico
- free capacity to provide
- cost of provision (function of congestion)
- region id
- building location x y
A road should be able to host many provision
units, especially junctions.
A road is next a consumer:
The consumption scheme is more tied to a
building instead of a road.
- type: rico
- demand unit
- region id
- building location

One could make a provider table and a consumer
table, in the fashion of entity component system
A road holds a list of indices to buildings.
These indices to buildings are used both for
the provider and the consumer.
A building is also connected to a road,
possibly.
Add a road, then a building?
Road will attempt to connect, fail because none,
then the building will attempt and succeed.
A road has a list of connected positions on map?
Or it is a cache of the value?

Or, a zone table, and an id table. The id
is a entity. A provider component, a consumer
component, and other things components.
ECS may have poor performance though? Not
necessarily. At least it is similar to the
road network

An alternative would be to build roads first,
then zones after. This way the zone is tied
to the road? 


Can this scheme be performed at smaller level?
For example, a sub unit is 32*32.


Interesting bit on memory
https://stackoverflow.com/questions/45803829/memory-overhead-of-typed-arrays-vs-strings
That says typed array have quite some overhead
compared to strings.

Saving
Can use localstorage.setItem('key','content')
with content being string. It requires using
serializable objects...
Either each module writes its separate object
with a key (ex ASZONE_ID, ASROAD_id), or
write one big object that holds all necessary
state and break it down further the line.

After some reading, the complexity of a system
depends on the reading pattern.
The likely reading pattern are:
- roads read other roads and properties on that
road (demand, unit, etc)
- view reading that is about display of tiles

Most evolution of the system will happen locally
over roads so a game state is better constructed 
from one master structure for each tile, or road 
tile and eventually more advanced structures 
elsewhere in needed.
Only the display part will not be able to be
memory efficient.

The structure may be
x
y
display tile
road or not road
debug
electricity provision + / consumption -
water provision + / consumption -
rico provision + / consumption -
pollution
if not road
  x road
  y road
if road
  congestion
  speed
  connectup
  connectdown
  connectleft
  connectright
  list of connected buildings?

The game state will be a hash of those, or a
array. Modules such as aszone and asroad don't
hold data themselves, but work on this master
game state. This master game state is what is
saved. The data layer is retrieved from this
master structure.
This however will require indexing to be
the same for all modules. Either its initialized
with a table size x/y to allow compact indexing
or just using a hash table.

Resolving a building works as such:
If residential
  remove all traffic itinerary
  
New rico idea:
A building has offer and demand.
Example:
Res building offers 6R, demands 3C and 3I.
Offer is registered at the nearest road.
The road knows it has 6 free R offer out of 6.
Upon resolution, building starts at road
and moves until it finds the 3C and 3I.
One R fills one C or one I, and adds 
one unit of congestion.

It could be agent based, where a building does
not know its agents.


Statistics based simulation
A building offers res and ico. The number
of rico will affect the traffic in the immediate
surrounding. The more a road has met demand,
the more its congestion. Congestion should
bleed to neighbors. Road networks should
know their total rico capacity and current use.
Congestion affects road efficiency, hence reduce
income. One could see that if a 100 ico demand
is met, then it bleeds 100 congestion unit
in the neighbourhood in a gaussian fashion.

The logic is that when there are many people
wanting to go to a high demand location
(high ico) then the surrounding area are busier.

This could lack the realism of agent based,
because in highly specialized districts
the traffic is supposedly unidirectional,
but this scheme would spread traffic in
concentric circles, hence you would have
two centers of traffic, and nothing in between,
regardless of the nature of the road between
the two districts.

Cellular automata like
Consider the network. Each building has a demand.
The demand is a dynamic variable that increase
as time goes, and decrease as cars reach it.
The demand has a maximum value, and cannot
increase over it. It is demand capacity. The
demand capacity increases as the building
grows. The building grows if the demand reaches
zero for some time (ie it is filled). The
demand capacity decreases when it reaches its
capacity for some time. 
A key factor is the rate at which it decreases.
It must decrease at the same rate an equivalent
demand is generated.

Each building has a offer, that depends only
on its level. Multiple buildings can aggregate
their offer. The aggregate becomes a car that
moves in the network and fills the demand.
Or it could be a car per building.
This is fine too, that data can be stored
per building.

Congestion works over time too. When a car moves
from a road to a road, the congestion increases
by its remaining demand. This may seem absurd
because some cars will take a longer road.
So high density will plug all road capacity
when it just generates its car. Why not, this
emulates rush hours.
How does speed impacts whether a car moves to
the next or not? Maybe road capacity is a
sufficient indicator, that is is road has
available capacity, moves, else wait.

This removes the need of knowing which demand
ties to which offer. It is even fine if a car
moves for an undetermined time?

The algorithm works like this.

Resolving a building car is:
Initialize
- Generate a car at nearest road
    set x y
- Fill it with offer RICO
- if road capacity is not free
    skip and wait status
    end
- move status

Move
- remove current car offer from road capacity
- if neighbour road node has full free capacity
    set x y to new road node
  else
    set x y to current road node
- fill in building demand with car offer
- remove filled car offer
- if car offer is zero
    wait status
    end
- add car offer to current road capacity

Machine state
waiting status
  initialize
move status
  move



Webassembly
Input output of webassembly is arraybuffer 
based. Hence each module (zone, road) must 
expose uint32array for the datalayer, and 
the wrapper for the module will colorize it 
accordingly.
Since modules have interaction, the web 
assembly instance is a master object that 
provides multiple datalayers.


Search algorithm
Traversing the road capacity requires to know
when to stop, otherwise there will be a lot of
empty traversal. A optimal solution would be
a asroad api that provides the next search
to perform, upon a function call. This requires
to have in input a state, upon which to build.
A step of the algorithm is to have the list of
edges (from, to, cumulative cost) to be explored.
Lowest cost element is traversed, and returns
next edges to explore.

example
a-b-c
  d
  e-f
Starts at d
in: db1, de2 - d
out: de2, ba2, bc3 - d, b
in: ...
out: ba2, ef3, bc3 - d, b, e
in: ...
out: ef3, bc3 - d, b, e, a

What to do in case of cycles?
There needs to be an history of traversed nodes
in input too. Better not to make it a state
for future async calls or simultaneous searches.

Async calls
Multi threading and webassembly specs have not
been specified yet. However, wasm input is to
be copied into the memory of the webassembly
instance, hence you cannot perform simultaneous
searches on the same module with two different
sets of inputs. So the problem of keeping the
state as an input may be not relevant, since
providing an input already changes the state
of the wasm module. An alternative may be to
clone the instance then run a search so
there is distinct memory zones where the
algorithm is working. This is compatible with
Javascript which needs cloning before
performing a search anyway.
There are two key data
- graph traversal data which is mutable
- graph data which is immutable and shared


So the two objects are:
- explored nodes
- next edges to visit

Should we keep it sorted?
Not necessarily, as long as the minimal cost
is being processed. The only thing is it will
need to scan the whole input for the minimal
cost. Appending by insert sort to always keep
the list sorted may be worthwhile? No, because
it will make indices change, see below.

Problem of path reconstruct
When a road has free capacity, it needs to
have an itinerary from start to end.
The itinerary can be built by reversing the
graph.
If the traversal data structure only grows, and
is never sorted, then it is possible to
reconstruct a itinerary because indices will
never change.
An edge requires a parent edge so it can be
reversed.


So far, the structure is a growing data structure
with a collection of edge, with:
from node index
to node index
cumulated cost
parent edge
processed flag

Algorithm goes like this:

function getNextEdge()
retrieve minimal cost unprocessed edge XC
append next edges
  from XC
  to XN
  cumulated cost of XC + congestion of XN
  index of XC in traversal
  false
set XC processed flag
return index of XC in traversal

function pathRetrieval(index of destination)
list
while (XC has parent)
  add XC to list
  XC = XC from parent index of XC in traversal
end
return list



