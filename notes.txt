Simulation engine simcity like

Road 1x1, serves also electricity and water
Road coverage 3x3
Building 1x1 for now, needs to be under road coverage
Road as connected component, each road a list of 1 tile building linked to it
Multiple tile building are cumulating their cost to a master tile, which will be the road connection


Demand RCI
Should be a local demand

Lot
* Level 
Indicates potency to meed demand
Capped by density
Increase if conditions met

Residential lot
*** Level 0
* Provides
Nothing
* Requires
1 Water
1 Electricity
Road
4 r demand

*** Level 1
* Provides
4 r unit
2 c demand
2 i demand
* Requires
1 Water
1 Electricity
Road
6r demand

*** Level 2
* Provides
10 r units
6 c demand
4 i demand
* Requires
2 water
2 electricity
8 demand met


* Commercial Lot
*** Level 0
* Provides
Nothing
* Requires
1 Water
1 Electricity
Road
4 c demand
*** Level 1
* Provides
4 c unit
4 r demand
2 i demand
* Requires
1 Water
1 Electricity
Road
2 demand met


Demand RCIO
Demand defined as the difference between actual unit and target unit.
time taken to raise level if requirement reached, then a new lot if none in waiting


asks 8r
Plop 2 residentials
electricity water road met
8 r, asks 4c 4i
Plop 1 commercial
8r 4c, asks 4r 6i
Plop 1 industrial
8r 4c 4i, asks 8r 2c 2i
Plop 1 residential
12r 4c 4i, asks 4r 4c 4i
Plop 1 commercial 1 industrial
12r 8c 8i, asks 12r 2c 2i
Plop 1 residential
16r 8c 8i, asks 8r 4c 4i
Plop 1 commercial 1 industrial
16r 12c 12i, asks 16r 2c 2i
Plop 1 residential
20r 12c 12i, asks 12r 4c 4i
Plop 1 commercial 1 industrial
20r 16c 16i, asks 20r 2c 2i
Plop 5 residential
40r 16c 16i, asks 0r 12c 12i
Plop 1 commercial 1 industrial
40r 20c 20i, asks 8r 10c 10i




4 res = 16r asks 8c 8i
2 com = 8c asks 4r 4i
2 ind = 8i asks 4r 4c

10 res = 40r asks 20c 20i
5 com = 20c asks 20r 10i
5 ind = 20i asks 20r 10c



***Algorithm for RCIO resolution

**Strategy 1: Road container based

Road network
Electricity/water
Each road can ask used and total capacity
Disconnected roads have different capacity

Function master check
Get next candidate for resolution
Check maintenance requirements
If maintenance requirements not met
  Downgrade? Disable? Provide no income? Upkeep cost? finish
Check level up requirements
If level up requirements met
  Upgrade, finish

Function check maintenance requirements
If none
  Finish ok
if need electricity
  If used > total capacity
    Finish no
If need water
  If used > total capacity
    Finish no

Function check level up requirements
if need road
  if no road, Finish no
If need electricity
  If not enough free capacity
    Finish no
  Add usage
if need water
  If not enough free capacity
    Finish no
  Add usage

A building provides units to a road.
A building has demand, starts from the nearest
road, and explore until it finds a free road
with free units.
If a building is removed, its units are removed
from its road and during the next cycle, a
building that used the road will remove
the full amount of the demand from it.
Number will go below capacity.

The rico statistics are hold in road.


**Strategy 2: Itinerary pair based

Process the simulation by type

Ratio of power/water grid determines income percentage.

Building residential has a requirement to have 
access to x commercial, x industrial. 
Remove all previous traffic. 
One traffic itinerary is set as a list of 
waypoints. 
Remove all traffic itinerary. 
Note that removing a road will not remove the 
traffic itineraries that go through this 
deleted road. 
They will naturally be deleted the next time 
the building is resolved. 
Starting from building location, 
explore the grid to find free commercial 
capacity, free industrial capacity, 
taking into account the existing traffic. 
Once a building is found, add an itinerary. 
Add back congestion level.

For converging to an optimal solution and 
reduce traffic, two buildings with overlapping 
traffic could exchange itineraries that cross 
each other. 

**Mechanism 1: Arbitrary building resolution

The scanning is arbitrary and starts at the
beginning of the map.
It iterates over the map index by index.
Alternatively, it can also moves in a building
queue, but the logic of adding and removing
from the queue must be solid. An example can
be a queue that grows as building are added
in fifo way. As a building is destroyed,
the tile is added to the queue, and scanning
an empty tile will just make it not queued the
next time. This way, scanning is performed
in a more economical method. In any case,
best is just a function that returns the next
tile to resolve (there may be no buildings).
Placing a building or replacing it will
update its sprite, but not its simulation data.
The simulation data is updated only upon
resolution.
The simulation data will hold a different state
than what is shown upon a change but it is fine.

**Structure 1: Building/Road data table (bits)

A building has an object that holds all the data
it needs for its resolution? or is it through
data tables? If it is table then
Zone id table, 8 bit or 16 bit
Density table, 8 bit
Pollution table, 8 bit
Congestion table (road), 8 bit
Speed table (road), 8 bit
Debug table (road), 8 bit
RICO offer * 4 (road), 8 or 16 bit
Connect tables * 4 (road), 8 bit ot bitmask

Using everything as table may be worthwhile,
but memory consuming?
Road admittedly only consumes, conservatively
a third of the map.
May be interesting to use unsigned int array
tables if they are faster, even limited
to 255 with 8 bit values for memory constraint.

Connect to is 4 direction, which requires only
4 bits, so a number from 0 to 15 is enough.
However, current implementation is holding the
index of the connected route, not just a flag.

**Structure 2: Road network specifics

Road network is an example of not array table
based, but hash table based. Array table may
be fine for data that is one value per index.
Hash table will be
necessary for more complex data. A consideration
is the size required for holding a table with
mostly empty data. Todo search hash vs array
memory consumption.
In term of performance, holey array have 10%
the efficiency of a packed array. A holey
array is one where there is an undefined
object in the mix.

**Structure 3: Cantor indexing

Note that the scheme of using cantor indexing
has a big overhead (twice memory reserved vs
compact indexing while only half of it is used)
but it allows extending.
If extending is a goal, then it may be better
to segment the grid into sub units, sub units
have compact indexing while unit grid is hash
based? Display would be limited to
a sub unit.

**Mechanism 3: Acceptable city size and junctions

Sim city 4 small city is 64x64, large city 
is 256x256. It allows region play so there
is that too. But for starters, it is fine,
hence there would be no need to support
extending dynamically, and so a static
indexing would work. However, extending
will be based on region play, So there is
the connection between regions to take into
account. One could say, if a region is a
simulation state, then it could be loaded,
churned into the engine, and updated without
having to display anything.
And so, keeping a sub unit to be 256*256 would
be memory efficient for data tables.
Junction roads between sub units however
need to be smart. For now, a road holds the unit
capacity provided by direct adjacents buildings.
A building having demands will explore the
network to feed on road capacity.
For subunits junctions, it can be thought as
checkpoints. Once all buildings have been served,
roads with remaining capacity can route to
these junctions and add up the free capacity
of that node + actual cost to fill that capacity
(on the sub unit provider).
Then on resolution of the neighbour subunit
(consumer), a traversal that explore the
junction will interpret it as a road with
free capacity (associated with a cost).
A difficulty resides in knowing whether to
settle with the junction, or to keep going.
As you see, a junction has many costs possible
so it does not fare well with bfs exploration.
Indeed in bfs it is supposed to resolve the
demand on a tile that is next candidate for
lowest cost. A solution would be to populate
the junction with many connections, not only
one road.
Once the consumer side has finished, the
provider side needs to update its congestion.
The junction becomes a consumer that has demand,
and must be processed as such by exploring the
network and add back congestion to the roads.

**Structure 4: Road data structure

A road is ultimately a provider first:
The provision unit is as such:
- type: rico
- free capacity to provide
- cost of provision (function of congestion)
- region id
- building location x y
A road should be able to host many provision
units, especially junctions.
A road is next a consumer:
The consumption scheme is more tied to a
building instead of a road.
- type: rico
- demand unit
- region id
- building location

One could make a provider table and a consumer
table, in the fashion of entity component system
A road holds a list of indices to buildings.
These indices to buildings are used both for
the provider and the consumer.
A building is also connected to a road,
possibly.
Add a road, then a building?
Road will attempt to connect, fail because none,
then the building will attempt and succeed.
A road has a list of connected positions on map?
Or it is a cache of the value?

Or, a zone table, and an id table. The id
is a entity. A provider component, a consumer
component, and other things components.
ECS may have poor performance though? Not
necessarily. At least it is similar to the
road network

An alternative would be to build roads first,
then zones after. This way the zone is tied
to the road? 

Can this scheme be performed at smaller level?
For example, a sub unit is 32*32.

Interesting bit on memory
https://stackoverflow.com/questions/45803829/memory-overhead-of-typed-arrays-vs-strings
That says typed array have quite some overhead
compared to strings.


**Structure 5: Saving in JS

Can use localstorage.setItem('key','content')
with content being string. It requires using
serializable objects...
Either each module writes its separate object
with a key (ex ASZONE_ID, ASROAD_id), or
write one big object that holds all necessary
state and break it down further the line.

**Structure 6: Save data structure

After some reading, the complexity of a system
depends on the reading pattern.
The likely reading pattern are:
- roads read other roads and properties on that
road (demand, unit, etc)
- view reading that is about display of tiles

Most evolution of the system will happen locally
over roads so a game state is better constructed 
from one master structure for each tile, or road 
tile and eventually more advanced structures 
elsewhere in needed.
Only the display part will not be able to be
memory efficient.

The structure may be
x
y
display tile
road or not road
debug
electricity provision + / consumption -
water provision + / consumption -
rico provision + / consumption -
pollution
if not road
  x road
  y road
if road
  congestion
  speed
  connectup
  connectdown
  connectleft
  connectright
  list of connected buildings?

The game state will be a hash of those, or a
array. Modules such as aszone and asroad don't
hold data themselves, but work on this master
game state. This master game state is what is
saved. The data layer is retrieved from this
master structure.
This however will require indexing to be
the same for all modules. Either its initialized
with a table size x/y to allow compact indexing
or just using a hash table.

  
**Strategy 3: Agent based Demand Offer

A building has offer and demand.
Example:
Res building offers 6R, demands 3C and 3I.
Offer is registered at the nearest road.
The road knows it has 6 free R offer out of 6.
Upon resolution, building starts at road
and moves until it finds the 3C and 3I.
One R fills one C or one I, and adds 
one unit of congestion.

It could be agent based, where a building does
not know its agents.


**Strategy 4: Statistics based simulation

A building offers res and ico. The number
of rico will affect the traffic in the immediate
surrounding. The more a road has met demand,
the more its congestion. Congestion should
bleed to neighbors. Road networks should
know their total rico capacity and current use.
Congestion affects road efficiency, hence reduce
income. One could see that if a 100 ico demand
is met, then it bleeds 100 congestion unit
in the neighbourhood in a gaussian fashion.

The logic is that when there are many people
wanting to go to a high demand location
(high ico) then the surrounding area are busier.

This could lack the realism of agent based,
because in highly specialized districts
the traffic is supposedly unidirectional,
but this scheme would spread traffic in
concentric circles, hence you would have
two centers of traffic, and nothing in between,
regardless of the nature of the road between
the two districts.

**Strategy 5: Car agent based

Consider the network. Each building has a demand.
The demand is a dynamic variable that increase
as time goes, and decrease as cars reach it.
The demand has a maximum value, and cannot
increase over it. It is demand capacity. The
demand capacity increases as the building
grows. The building grows if the demand reaches
zero for some time (ie it is filled). The
demand capacity decreases when it reaches its
capacity for some time. 
A key factor is the rate at which it decreases.
It must decrease at the same rate an equivalent
demand is generated.

**Strategy 5.1: Car aggregate alternative

Each building has a offer, that depends only
on its level. Multiple buildings can aggregate
their offer. The aggregate becomes a car that
moves in the network and fills the demand.

**Strategy 5.1: Per building car alternative

Or it could be a car per building.
This is fine too, that data can be stored
per building.

**Strategy 5.2: Car generation

Car capacity is defined by density.
Car volume generation is defined by density.
That is a high density zone will generate
cars often, a low density zone will generate
slower.

**Strategy 5.3: Car based congestion

Congestion works over time too. When a car moves
from a road to a road, the congestion increases
by its remaining demand. This may seem absurd
because some cars will take a longer road.
So high density will plug all road capacity
when it just generates its car. Why not, this
emulates rush hours.
How does speed impacts whether a car moves to
the next or not? Maybe road capacity is a
sufficient indicator, that is is road has
available capacity, moves, else wait.

This removes the need of knowing which demand
ties to which offer. It is even fine if a car
moves for an undetermined time?

**Strategy 5.4: Algorithm

Resolving a building car is:
Initialize
- Generate a car at nearest road
    set x y
- Fill it with offer RICO
- if road capacity is not free
    skip and wait status
    end
- move status

Move
- remove current car offer from road capacity
- if neighbour road node has full free capacity
    set x y to new road node
  else
    set x y to current road node
- fill in building demand with car offer
- remove filled car offer
- if car offer is zero
    wait status
    end
- add car offer to current road capacity

Machine state
waiting status
  initialize
move status
  move

**Strategy 5.5: Timestamp relation

The system is time driven. It has a queue of
timestamps, where the next event should happen.
A building has at max one event in the queue.
If not using queue, then buildings can be
pooled, and the event check is happening
periodically.
Car movement is defined by road congestion
and road speed. Next movement happens at a
timestamp function of the road speed and
road congestion.

If using a queue, then this structure is
[index, timestamp]. Problem is to keep the
queue ordered at all times.
Timestamp is not save/pause friendly, so it may
be better to use a internal timestamp that is
incremented when there is a update loop.
This internal clock must be saved.
In javascript, max integer is
Number.MAX_SAFE_INTEGER, so there is a check
to perform here.

**Strategy 6: Area of effect based

A building is processed at a certain time. 
It has a certain offer to distribute.
It has a distance capacity. The area of effect
stops once the distance capacity is depleted.
The distribution is through an area of effect.
The area of effect follows roads, starting
from the building. It follows all roads in a
breadth first depth. Upon checking a road,
it transfers the offers to free buildings
around, raises the congestion of that road
and reduce the distance capacity, as a function
of the road congestion.
Fullfilled demand decreases over time.
Congestion decreases over time.
High congestion reduces the spread of the
area of effect. The building will therefore
only serve near zones, nearest first.
This looks like the most realistic.

**Mechanism 6: Road traversal

Classic implementation is breadth first.
A separate data structure could work fine.
See Mechanism 7 for the impact of a separate
data structure.

Implementation shows that a road is added at
most only one time to the data structure, in
particular the 'to' is unique.
However, this only allows one parent. Since
it is a tree, it is not possible to get the
childrens nodes. How do you get the leaves?
If you start from a leaf you can get to the
root but not the reverse.
Or, in fact you could. Roads have the connected
information (north, south, etc). So knowing
the root, one could navigate up to leaves.
Therefore saving the state of a traversal
could be possible, although maybe
slightly computation intensive because
there is no way to know which are the last
leaves except by traversing the tree from the
root. But I could try.

A traversal data structure had the benefit of
being savable, and many could run at the same
time. Moving to a storage in the grid makes
it impossible to run multiple traversal paths
at the same time. Hence, no multicore on a 
single state. That is not a bad thing though,
since multicore makes things unpredictable.
Multicore will be available in running multiple
independant simulations.

**Mechanism 6.1: Road traversal on grid

The requirement is that the data structure
contains all leaves on a list, which
incrementally grows as traversal goes,
and a lot of the elements are refered by their
indices instead of an other key. The index
is the unique key taken into account, because
this is the order of storage in the old data
structure. If it was any other key, that would
mean to perform a lookup each time a data must
be accessed.

Changing to the to index as a key could be
good.
A new algorithm could be that.
From a starting point, register the cost (the
road capacity), the parent (none), and the
processed flag (added, not traversed).
Lookup for the leaf with the lowest cost,
that is added not traversed.
The lookup is performed at the start, and
since there is only one leaf, choose it.
It becomes traversed.

Child leaves are naturally connected, so check
the isConnectedTo instead, and if they have no
added flag, connect, and initialize their cost,
their parent, and mark them as added not
traversed.

Which leaf should be traversed? The one with
the lowest cost.

Note that it is necessary for a node to have
3 states, not processed, added, and processed.
The added state (yellow) indicates a node
that is reached and will be one of the next
candidates.

The transition to this new method requires
a transition from a edge graph to a node
graph, and a change to the whole algorithm.
As a change to, the starting node is a
traversal added not reached.

To get the next step, the algorithm must be:
From the start
check all directions
if one is traversed and is not parent,
  put it in a queue to process
if one is added,
  put it in a queue to costify
do that until there is no more to process.

next, process the costify queue.

This is why it is best to get the first tile
as a processed, so the exploration towards 
four directions is correct.


**Mechanism 7: Checking all buildings

For now, one can just pool over all buildings
until the tick is reached.
Pooling experiments on 96x96 work fine, but
on 128x128 it is at a crawling speed.
It looks like a critical mass at this threshold.
Therefore priority queue seems in order,
or a tick happen over the course of multiple
frames. The later solution may be complex
because i have to assess how much time i have
until the next frame and how much computation
I can fit in this time frame.

The checking is done until the capacity is
depleted, in the same tick if possible.
Otherwise one must save the state of the check.
Can it be done on the grid? Possibly, as a
variable. That means there is only one single
trip check at most within a tick. System 
is updated each frame loop until aoe is
depleted.
Buildings are not checked all at once in the
same tick, there need to be a timeout before
it is checked again so offer distribution can
occur sparsely.
Trip check could have been saved as values on
the grid, but is now saved as a data structure
stand alone, and could be saved as such in
save data, assuming there is always only one
data structure. The caveat is memory size is
not fixed.
// struct is
// array = [
//   from of starting point
//   last explored index,
//   number of edges,
//   collection of edges * 5
//   ]
The from is unique. If it was saved in the grid
then processing would have to scan for it to
find it.
Same with last explored index.
Other alternative is to never save game if there
is a traversal path in progress, i.e. a game save
occurs always at the start of the next check,
even if it occurs during a tick.
Other alternative is to save the state on the
grid. The traversal state is saved into the
grid. However, the current implementation is
not compatible with interrupting a traversal
in the middle. The update unit is a tile.
The tile per call/frame depends on the framerate.
The traversal necessarily finishes at the tile.
One could change the system to a number of
checks instead, lets call them cycle.

A cycle can be defined as one action that
consumes a little time. The cycle per frame is
capped dynamically.
The checking should be organised in steps:
- For demand, checking if the demand is met
counts as one cycle even if it is very
short. For now at least.
- For offer, increasing the traversal state
and all surrounding buildings and adding to
their demand is one cycle.
Hence there must be two flags to track the
progress:
- which building is being checked
- which step is being run

So, should building be scanned one by one?
One way to do this is to chain buildings
through adding order. A building will hold
the next and previous building to scan.
Holding previous and next is obligatory,
as well as holding one point of entry, such
as the last building added.
That can work as a circular linked list.
Destruction of a building must be ordered

Road checking may be more complex.
A corner might be checked up to 4 times from
4 directions, hence it may be filled up multiple
times.
One could also set a flag on a building, that
indicates which next tick the building demand is
authorized to be updated, which is tick + 1.
Upon checking a road, all buildings within 2
blocks on 4 directions are tested.

How do i know when to stop checking?


Observed a crawling speed on performing
resetTraversalPath at step 3 (after
traversalPath finishes). resetTraversalPath
is too big of an operation that does not fit
a frame cycle, unlike the others. Consider
performing reset traversal path over
multiple cycles, or performing the commit
change log over multiple cycles.
The solution of commiting change log over
multiple cycle is interesting, because that
could batch modifications at a rate controlled
by the render. One could also say, next tick
does not happen until the change log is all
empty.
It happens that the asroad change log exploses
in size (from 80 to 800 in 16*16 grid and 5*5
road square) when a reset traversal path is 
performed.
The actual formula for the change is this:
Road has 3 changes per traversal, it is
traversed by as many buildings as there is.
More importantly, a road is added multiple
times in the commitChangeLog, hence a road
is repeatedly asked to be refreshed, because
it is added in the changelog multiple times
before it is processed.
So, we can do a policy to always empty
the change log before moving to the next
update tick, or the next frame.
What is the render policy?







**Mechanism 8: System ordering vs framerate

The systems could work as such:
All systems that need to be updated are run
once per loop. If they are ready to go to next
tick, they return true, else if they have
remaining tasks they return false. Tick stalls
until all systems are green.
They have in input the current tick, and the
remaining computation time for the current
frame.
Systems are executed in turn. Only when one has
finished computing, that is it moved to the next.
Computation time is distributed with a counter
tied to fps, that is if it is slowing down,
the next framerate will process less tiles.

Graphical refresh was relatively linear in the
number of operations performable.
Adding multiple steps after that in which the
steps are not homogeneous is more difficult.

There is two level of cycle comsumption
The first level is the graphical engine.
MMAPRENDER
If a frame got skipped, that means there are
too many calls to refreshTile and you have to
reduce the number of tiles to refresh.
The second level is the computation engine.
ASRICO and ASROAD
They have a large number of computation to 
perform over a lot of tiles, and if the frame 
skips, then the computation needs to tone down
and its allocated cycle per call is reduced.
Minimum is one machine cycle, which is the 
basis of step by step computation.

Speed measure may be necessary to regulate
the number of ticks as the complexity of the
city increases, which induces a difference in
simulation speed. Stabilizing the number of
ticks is a way to control the simulation
speed. It could be done as a max number of 
ticks per second, and once the limit is
reached on that second it skips. But this
induces a non uniform simulation speed
which may impact the smoothness. To increase
the smoothness, the speed could be not
ticks limit per second but one tick per x
seconds. Hence we have a direct control over
how fast the simulation happens, and it
is made regular.
As of now, a tick will happen over many frames
anyway.
It is also an opportunity to induce frameskip
to increase further simulation speed. That is,
the tick happen, but the graphical refresh 
is performed after more ticks. This frameskip
will induce to hold a "refresh flag" for
each tile, that way we avoid redundancy.
Or we could also have a set of tiles to
refresh which holds only unique values.
The refresh could therefore be done over
multiple frames.

Tick speed is now a value that shows the
frequency.
-1 is stop.
1000 is one tick every 1000ms. Speed 1.
100 is one tick every 10ms. Speed 2.
0 is max speed. Speed 3. However, it seems
the tick speed is limited only to 60 per sec,
owning to the speed of the refresh call.
It could be interesting to go even further.
The strategy will be to consider that rico
must use the maximum amount of cycle it can
before it triggers a slowdown. However, this
must be done separately from graphical refresh.
It cannot be implemented in rico, as rico
must stop upon the tick finishing to let other
systems update (polution, energy, etc).
It must be updated at higher level such as
zone or map. For now, the tick decision
is at zone level.

The decision to make smoothness key requires
frames to never be saturated, i.e. never skip
a frame.
A full call therefore must not use more than
16 ms, or 33 ms depending on target fps (60 or
30).
The flow can be:
- Retrieve time
- Refresh a number of tiles
- Refresh a number of simulation cycle

The render refresh is for now processing a
number of batches per update call. The number
of batches per call is adjusted according to
previous calls, if it was too slow then
it is reduced. It is in fact necessary because
the actual effect of the batches is only
observed at the next frame, ie in the current
frame I set x batches. Once update is finished
the batches are processed and only then do
I know if x batches were too many (because
frameskip), or if they were within capacity.
It is especially important to keep some budget
at the end of the call to process the number
of batches promised.
Strategy can be to update a number of batches.
Consider a fixed budget of 16ms.
Consider a render budget of 10ms. 
Consider a compute budget of 6ms.
Number of batches to process (nbtp) is set.
*fully processed = nbtp > number of batch wait
*frameskipped = dt over
If not fully processed not frameskipped, 
  raise nbtp by 1,
  keep the render budget the same.
If not fully processed frameskipped
  keep nbtp
  raise render budget (reduce compute budget)
  if render budget maximal already
    reduce nbtp
If fully processed not frameskipped
  reduce render budget.
If fully processed and frameskipped, 
  raise render budget.
The strategy seems to be able to maintain a
stable framerate. The comparison currently
done is a asrico loop exit once date reaches
the time limit. However, the comparison is
performed every cycle so it might be expensive.

A possible improvement is batching cycles, if
and only if the date.now call is expensive.
Date.now does not seem too expensive according
to jsperf. Profiling is required.

The next problem comes now in the commit log
queue.
It might be a design decision to make sure the
tiles are updated before simulation engines
run. Updating the graphics is done by
mmaprender, and the amount of sprites to update
depends on the commitchangelog.
The data is changed by the systems, but
the commitchangelogs are order to reload
textures. However, the texture is reloaded
only if it is within the visible range.
The implementation of commit change log queue
has the drawback of accepting multiple times
the same tile except if the structure is a
set or hash or fized array. In the case of
asroad, a road tile is added multiple times.
In the case of a tick that is interrupted in
the middle, the mmaprender is refreshing each
time. Which is... possibly fine for debugging?
Consistency may require buildings to be updated
only between ticks, not within one. But for
debug purposes it is desirable to see the
advance during turn. It however decreases a lot
the simulation speed, but it is in fact a 
secondary speed control, in the sense that
you can vary the rate at which graphics update
(such as every tick, every x ticks, or within
ticks) by imposing a starting condition.

To speed up the refresh of graphics of tiles
that have changed, a possible implementation
can be using a sort of linked chain.
A fifo is most desired for consistent
across frames update. Hence for a fifo to
work a tile must hold the index of the next
tile to update. Hence when adding a new tile
the change flag of the last tile must point
out to the newest added tile.
The algorithm is as such:
Adding to the list
- if first tile is empty
    set first tile = cindex
- else
    retrieve last tile, pindex
    set pindex change flag to cindex
- set cindex change flag to cindex
Removing from the list
- if first tile is empty
    end
- else
    retrieve first tile 
    set first tile equal to ft change flag

Since the max size
is known, it could be stored as a grid flag.
Hence writing multiple times the same tile
will trigger a refresh. A loop could pool the
grid to build a updatedtiles structure, which
is used in place of the commitchangelog one.

Is it a waste of space? Would it be better
to use a datatructure such as set or hash?
Ultimately I will unlikely store more than
512*512 amount of data (256kb), and I am likely
to store instead 128*128 (16kb) of data.
A direct array with some logic is not 
too much wasted space compared to a texture.
Writing it into the asstate may be too much
due to the fact that it is not a sim data,
it is a rendering issue which is supposedly
changing independently from sim data.
However a small issue happens for the sim engine
because engines may have a direct call to
data or render layer, and this is superfluous.
A better option could have been flags in
asstate, which is independant. Change flag
can have other uses outside rendering, such 
as bulldozer. A bulldozer option is saying
that the tile needs cleaning; can it be done
without tick waiting? 
The change flag needs to be processed at the
end of the tick, which will process in the same
tick the render change, and in the next tick
the building orders.
The map refreshing can either happen before
engines updates, in which case we see all
intermediate states (but is slower) or it
can be put after all engine updates, in which
case we don't see anymore the intermediate
state.



**Interaction during simulation

A point of detail about adding and removing
tiles: the actions must be validated between
ticks. Otherwise, if a road is deleted during
a tick, the traversal state may break at reset
and some roads will stay visited and will
never be available for further traversals.
Hence actions must be synchronous, but orders
are asynchronous.

To implement this, a possible implementation
may be:
- process of actions at tick end/begin only
    this requires a way to cumulate orders.
    Once tick starts or ends, the tiles are
    changed accordingly to their new state
    and their state changes, their clock reset.
    
- order cumulation may be:
    a buffer state, in the grid
      pro: it is saved in save state so
        actions are remembered
      pro: only one future state per tile
      con: to link to the change flag mecanism 
        for knowing when changes happen
    or a buffer user interaction
      pro: memory economy
      pro: direct access to which tile has
        changed

If I harness the change flag mecanism, then 
it limits its capability in updating the 
display during a frame (which relies on it
happening in-tick).
So the orders are to be processed between two
engine ticks, so the engines can run on new 
data. 
The actual changes requires upon destruction
are:
- reset of any future queue
- change of road network
- must not affect distribution

The commitDataChange was at first a graphical
need, that could run separately from the
simulation engine and hence separate from
any tick consideration. That way, graphical
update happens when it can. The only
consideration is it takes some compute time
out of update loop so the speed decreases.
Note that graphical refresh happens anyway
for mmaprender (map drag), only the refresh
of new tiles is concerned.

If I link the action buffer to it, then it
becomes tied to ticks. It may be a necessity
if we consider other uses of the change flag.
However one could also consider two queues,
one for hidden data change, one for visible
graphic change.
Most parameters changes must be passive (that
is the data is changed but its dependencies
are not affected until they query the data).
Exception may be roads water electricity.
A change in the data must be trigerred for
visible change, but hidden data does not
warrant it.


About engines, for now ASZONE is the only
one. The tick system is integrated in ASZONE
but could be taken out and put in ASMAP
instead. But ASZONE could be the master
fot tick based simulation, ie all other sim
components could be hosted and coordinated
by it.

Graphically, the difference between a order
in progress and the actual building could
be ghosts or translucid tiles, stating change
is in progress.


** Performance and compute vs render
Grid of 4*4 zones, total 9 zones, each zone
only outer zone being residential.
Road about 112 blocks
Residential about 108 blocks
- at 60fps, on pc, 
small speed is 23 frames
mid speed is 23 probably, 390 ms per tick
high speed reach the same, hence even computer
can not process the full cycle.

One optimisation performed is moving
addRoNodeList to its own function, it saved
quite a lot of time and possible reduced from
700 mspt to 300 mspt on mobile (to confirm).

One possible place of optimisation is the
avoidance of recomputing the current node list,
which now takes about 1/3 of computation time.
The problem with it is the constant recompute
of the whole list, which is the more expensive
the bigger the road network.
There is no requirement for the node list
order.
There is room for a little improvement.
The node list is about getting the road network
that is connected by the traversal.
We know when something is added, that is upon
call of traverseNextNode, its neighbours are
added to the tree.
One possible strategy is to implement a linked
list of the traversal node, in the same manner
as the change flag. I have no lookup 
requirements, only retreiving the whole list.
Once an element is added, it stays in the list
until the whole list is cleared.
So one could save the list as a regular member.
Did I make the choice of having no member
in road and save everything into asstate?
It helps because it makes it independant from
saving loading state, so it is a good thing
probably.

** Webassembly
Input output of webassembly is arraybuffer 
based. Hence each module (zone, road) must 
expose uint32array for the datalayer, and 
the wrapper for the module will colorize it 
accordingly.
Since modules have interaction, the web 
assembly instance is a master object that 
provides multiple datalayers.
The biggest unknown is related to the call to
the engine. As of now, the engine is called
and updated every frame, and the graphic as
well. Hence the engine cycle is performed
every frame, but is only cut into smaller
processing units. By moving to web assembly
the cost of calling the wasm engine may be too
big to be called every frame which would
induce frameskip.

** Web worker
A good alternative to this is having the engine
to run separately from the graphical thread.
The engine would run in wasm, never exiting,
or only exiting after some time, while the
graphic thread would register user ui and
the rest without interruption. That would
require a asynchronous architecture between
simulation and graphic, which is a good idea
to invest in as we are permitted to run both
at the same time without interruption or
inferrence of the time needed. It potentially
removes the need of synchronous change between
ui and engine, and force a asynchronous
architecture. I am treading in unknown
territory.
Web worker is possibly the way to go for this.
It works as a number crunching thread
that communicates with the main thread through
messages.
The mechanism is through using ArrayBuffer
to transfer data to web worker. The reference
is readable by the worker, not the main, until
it is transferred back to the main.
Hence after all the crunching is done for
one or more ticks, we are notified back and the
graphic takes its time to refresh.

Dataflow:
Data resides in ASENGINE as a ArrayBuffer.
The ArrayBuffer is transferred in post message
to the engine worker, and hence becomes
unnaccessible on engine space. The view itself
(Int32Array) probably is not accessible either.

ASSTATE should not be a container for the data,
it should be a wrapper/reader/interpreter for
it. That way it can be used by both engine
and worker.

The architecture can be:
- asmap calls asengine, provides a callback
- asengine process the call, sends messages
    to worker, process the worker's answer
    This requires data to be resident in
    engine, or in worker
- Webassembly could work within the worker
    that would require data to be inside
    worker anyway.
- data should live most of the time in the 
    webworker, for it to be able to handle
    incoming messages.
    Periodically, UI requests a copy of the
    table, makes a copy of it, and send it
    back.
    Or maybe the way to go is just put data
    in the modules, and when needed return
    some values. Hence no back and forth?
    Webassembly possibly does not work like
    that and must have memory provided.
- Worker has no access to any global module,
    and has no way to include any other, so
    it must live in the module file.
- to enable/disable worker, one
    could use a standard message to communicate
    with modules. Either engine directly calls
    them, or send a message to the worker which
    will handle it.
- another issue is the readonly of some
    properties such as table size, where
    there is not much chance that it changes
    accross the run (except at load), and
    hence that global may be read only.
    If however it must be read from asstate,
    then it must be done early in a call.
  UI | Engine | Worker | Module + data


- One caveat is debugging. I would be near
impossible to pause mid tick or during exec.
- Another issue is the graphic refresh must be
reading something else to display, not asstate.
This is particularily problematic for
when ui is switching the view to look at
something else than the master tile data.
What could be done is upon change view request,
the worker can either relax the computation
and give it back for a time, or return a copy
of the table. Making a copy is likely the
safer solution because the copy is saved in
the mmaprender and it allows scrolling with
having to block the worker. A new table
is requested on demand?
- retrievechange is after webworker is done.
saving loading too
- play speed to be excluded from asstate? That 
cycle count does not depend on it in tick,
but may depend on it between ticks.
- Debug window requests
Aszone is in the worker so it is fine; Same for
Asrico and Asroad.
- aszone requires gettablesizex and y are 
required often by render
- aszone requires getdatazonebyid
- aszone setdataid is likely an obstacle
However, mmaprender is using ASZONE, ASROAD
and ASRICO as stubs to access data, via
getDataId. The getDataId is distinct between
these modules. Their definition change 
according to visualization mode and other
things. The returned tileId is therefore not
what is saved on asstate. This may be the main
reason to have a copy of asstate resident in
the ui while there is one in the worker too.
In practice, the tile information are within
modules living in ui space; this is how texture
are built. That means the data interpretation
to tile id could be done on the ui thread,
using data state in ui thread. It is not
practical to request engine to provide the
tile id at each request. So the likely easy
solution is to maintain two asstate, one
being read only. That solution causes an issue
though because retrievechange flag is used
by ui and updated accordingly. Or, changeflag
is processed by engine only and changes are
returned upon request.
Alternatively, MMAPDATA holds a table of cached
tileIds. That table is reconstructed when
switching module, while some indices are
refreshed upon retrieve change (and the tileid
value is also returned?).
Graphical refresh of all tiles is cumulated in
the batchflag, and is processed accross multiple
frames.
How can be the table tile transferred to ui?
Old implementarion had mmapdata read its
target module upon request of refreshTile
and refreshAllTiles. To remove this reading
it would be the engine providing the tileid
values. The possible issue comes from switching
views, where it must request a refresh.
The good thing is the changelog can act as a
buffer and be processed asynchronously.
Possibly, engine is best updating incrementally
so it can be interrupted at all times. However
should some messages be postponed until they
are safe to process? Not sure about the
inplementation.

Web worker starting time?


It is possible that transferring a small
table 128*128 is about 20 ms?
See link for benchmark + demo
https://www.loxodrome.io/post/web-worker-performance/

This might require a full rearchitecture to
separate ui call and engine sim.
The render is stand alone. Upon ui button press
it send messages to the web worker or engine,
which returns the changes.
UI and render are bundled together, while
simulation is separate.
The processing flow changes however. Upon
call of engine execution, there should be
no promise of a return value, no waiting of
the engine. Just a simple do and forget,
except in the cases of;
- save/load
- view switch data
- commit display change
    this one is a possible difficult part
    engine returns now one change at a time.
    would it be more efficient to retrieve
    a batch of changes and processing them
    until depletion?
- getTileTextureName for all sprite
    initialization
    Where should texture name be saved?
    In engine or in render?
    Where should basic texture creation
    happen? Texture creation requires a name,
    and some basic properties such as name
    and color; as of now they are stored
    in a module that executes PIXI objects.
    One could to a standard template?
    Should there be a common definition file
    shared by ui/render and engine?
  even for the graphical part of the city view
  there is a plethora of tiles to assign.
  one needs to retrieve the identifier for
  tiles through a list? Or is it hard coded?
  
There are two kind of operations that the engine
should handle: short direct call and long call.
The short direct call is for small, direct
results that will not make ui thread lag.
Long calls must be message based.
For now, the calls to engine are limited to
retrieving data state and editing tiles, and
this is done through direct calls.
A message based call may work? ASENGINE can be
an experimental intermediate.
The wasm exports functions so the ASENGINE
can be a wrapper for multiple functions.
The form is a table of callbacks. For each wasm
callback a matching ASENGINE call will work.
ASENGINE will function as the glue.

Webworkers are async calls while wasm are
setialized.

** Multi threading
Multicore is very interesting in the sim engine.
There are task that can be processed distinctly.
Spawning multiple workers is a quick way to
speed up, if workload is parallelizable.
Each workload could also work with a webassembly
routine.
It could also be modules working separately.
That means for example that road checking,
which is today saved in asstate, may need to
move separately so it is performable in //.
However that supposes it is not savable and
this limits saving during a tick.
Impacted modules are for example road
distribution and checking.


  

Web worker is started and run sometimes;
it is a good starting point for webasm.



** Linking between asrico and asroad
The current state is the logic of rico point
distribution is handled by asrico.
It could be that asrico only handles leveling
up the states and the points, while another
engine queries which building has things
to distribute and queries asroad to find
the locations.


// ideally, max fps being limited to 60
// the update update cycle runs 60 times
// per second, hence tick per frame
// can be computed. 


Zoning vs display
asrico proposes a view only focused on zoning.
aszone is more general purpose.

Buildings for the time being have only one
progresson axis, in density. Zoning is a way
to limit density, to avoid overflowing the
capacity of the road network.
Density level increase as demand is met.
There is 9 density levels.

Later, progression can be two fold, in density
(user controlled) and in richness.
There will be 3 richness levels.

Touch
On first touch, map always stays under touch
on a static point.
On second touch, it is impossible to keep
static points under touch.
Current strategy is to keep a static point
under first touch, and distance between touch
defines the zoom level.
New strategy could be static point being the
middle of the two touches. When moving two
touch rotation, keep the static point to
middle of the line between two touches.

Implementation requires to know the width and 
height of the screen, in order to be able to
infer the camera map point that makes the static 
point coincide with the middle of the touch.






Search algorithm
Traversing the road capacity requires to know
when to stop, otherwise there will be a lot of
empty traversal. A optimal solution would be
a asroad api that provides the next search
to perform, upon a function call. This requires
to have in input a state, upon which to build.
A step of the algorithm is to have the list of
edges (from, to, cumulative cost) to be explored.
Lowest cost element is traversed, and returns
next edges to explore.

example
a-b-c
  d
  e-f
Starts at d
in: db1, de2 - d
out: de2, ba2, bc3 - d, b
in: ...
out: ba2, ef3, bc3 - d, b, e
in: ...
out: ef3, bc3 - d, b, e, a

What to do in case of cycles?
There needs to be an history of traversed nodes
in input too. Better not to make it a state
for future async calls or simultaneous searches.

Async calls
Multi threading and webassembly specs have not
been specified yet. However, wasm input is to
be copied into the memory of the webassembly
instance, hence you cannot perform simultaneous
searches on the same module with two different
sets of inputs. So the problem of keeping the
state as an input may be not relevant, since
providing an input already changes the state
of the wasm module. An alternative may be to
clone the instance then run a search so
there is distinct memory zones where the
algorithm is working. This is compatible with
Javascript which needs cloning before
performing a search anyway.
There are two key data
- graph traversal data which is mutable
- graph data which is immutable and shared


So the two objects are:
- explored nodes
- next edges to visit

Should we keep it sorted?
Not necessarily, as long as the minimal cost
is being processed. The only thing is it will
need to scan the whole input for the minimal
cost. Appending by insert sort to always keep
the list sorted may be worthwhile? No, because
it will make indices change, see below.

Problem of path reconstruct
When a road has free capacity, it needs to
have an itinerary from start to end.
The itinerary can be built by reversing the
graph.
If the traversal data structure only grows, and
is never sorted, then it is possible to
reconstruct a itinerary because indices will
never change.
An edge requires a parent edge so it can be
reversed.


So far, the structure is a growing data structure
with a collection of edge, with:
from node index
to node index
cumulated cost
parent edge
processed flag

Algorithm goes like this:

function getNextEdge()
retrieve minimal cost unprocessed edge XC
append next edges
  from XC
  to XN
  cumulated cost of XC + congestion of XN
  index of XC in traversal
  false
set XC processed flag
return index of XC in traversal

function pathRetrieval(index of destination)
list
while (XC has parent)
  add XC to list
  XC = XC from parent index of XC in traversal
end
return list


